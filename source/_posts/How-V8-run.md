---
layout: post
title: How V8 run？ 
subtitle: 是时候看看v8了
author: "malin"
header-bg-css: "linear-gradient(to right, #5cadff, #09EF46);"
categories:
  - js
tags:
  - js
---

v8如何执行js代码的呢？主要分为：

- 编译
- 执行

机器只认识机器语言，js这种高级语言需要先转成汇编语言再经过汇编语言编译器转成机器语言就是0101才能执行。
v8可以理解成一个虚拟机，虚拟机通过模拟计算机的各种功能：CPU、寄存器、堆栈等，虚拟机还具有自己的一套指令系统。
所以对于js编写者来说，不必担心自己写的代码在不同的计算机中运行结果不一致（cpu类型不同指令集不同），v8都可以转成统一标准的代码。
v8是虚拟机用来编译和执行js代码。

### 机器语言

CPU只认识100010101这种二进制的机器语言。但是这种二进制代码太难记了，不好写。于是就有了汇编语言。汇编语言长得人能看懂了，但是CPU不认识他，于是就需要汇编编译器
来将汇编语言翻译成二进制的机器语言。并且不同的CPU指令集不同，用汇编语言来编写代码需要做大量的适配，并且代码长度很长。所以有了py3，java，js，c，go等高级语言

### 高级语言

CPU也不认识高级语言，这时候有两种方法解决：

1. 解释执行，输入代码-解析器解析-中间代码-解释器解释-输出结果
2. 编译执行，输入代码-解析器解析-中间代码-编译器编译-机器代码-执行-输出结果

不同高级语言都有自己的虚拟机去做这些事情，v8就是js的引擎。苹果是javascriptCore

V8采用的是混合执行，解释执行 + 编译执行

## V8工作顺序

### 准备工作

- 内存初始化堆栈结构，存放变量
- 全局作用域，全局变量
- 全局执行上下文，内置函数，全局变量
- 消息循环系统，包括消息驱动器和消息队列，eventloop，如同v8的心脏不断接受消息和决策如何处理

### 编译，执行 

采用JIT技术，解释 + 优化编译

- 结构化代码，生成ast语法树
- 生成ast同时生成作用域
- 解析器解析出中间代码
- 解释器解释
- 输出结果
- 高频代码会被`监控解释器`记住，走`优化编译器`
- 编译成机器代码
- 执行
- 产出结果
- 代码改动会进行`反优化操作`重走解释器

## V8如何处理闭包

### 惰性解析

v8在编译程序时选择了惰性解析，遇到函数声明时并不会解析函数内部代码，只会解析顶级代码，生成AST和字节码

```js
function foo(){
  return 1;
}
var a = 1;

// 产出AST，下面代码结构类似，但并非真实AST

// function:{
  // foo:{
  //   name: 'foo',
  //   code: 'function foo(){
  //     return 1;
  //   }',
  // }
// }
// variableDeclear:{a:1}
```

这个做法可以大大的缩短js编译时间。  

### 惰性解析如何解决闭包

#### 闭包问题

> 闭包即，函数的内部函数持有了非本作用域的变量，并且这个函数被已返回值的形式传送到了外部作用域。

这是就会产生两个问题：

1. 在外部函数执行结束时，被内部函数引用的变量是否应该销毁？
2. 由于使用惰性解析，没办法知道内部函数引用到了外部变量，所以在栈中，内部函数被外环境所持有，但是外部函数已经被销毁，此时v8并不知道内部函数还用了外部函数的变量。那么变量将会被错误的销毁

#### 预解析器来排忧解难

预解析器主要负责在惰性解析时，快速解析函数内部代码是否存在以下两种情况

1. 代码是否有错误
2. 是否存在内部函数引用了外部变量，如果引用了外部变量，预解析器会将变量复制到堆中。

基于第二点，就算外部函数执行完毕被销毁了，但是内部函数引用的变量被存放在了堆中，所以就不会出错了！

## 总结

### V8做的优化

#### 编译

1. JIT技术，加快js编译+执行
2. 惰性解析 + 预解析器（解决闭包，查找错误）

#### 执行

1. 