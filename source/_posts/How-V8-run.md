---
layout: post
title: How V8 run？ 
subtitle: 是时候看看v8了
author: "malin"
header-bg-css: "linear-gradient(to right, #5cadff, #09EF46);"
categories:
  - js
tags:
  - js
---

`v8`如何执行js代码的呢？主要分为：

- 编译
- 执行

机器只认识机器语言，`js`这种高级语言需要先转成`汇编语言`再经过`汇编语言编译器`转成`机器语言`就是0101才能执行。
`v8`可以理解成一个`虚拟机`，虚拟机通过模拟计算机的各种功能：`CPU`、`寄存器`、`堆栈`等。虚拟机还具有自己的一套`指令系统`。
所以对于js编写者来说，不必担心自己写的代码在不同的计算机中运行结果不一致（cpu类型不同指令集不同），`v8`都可以转成统一标准的代码。

### 机器语言

`CPU`只认识`100010101`这种二进制的机器语言。但是这种二进制代码太难记了，不好写。于是就有了`汇编语言`。汇编语言长得人能看懂了，但是`CPU`不认识他，于是就需要`汇编编译器`
来将汇编语言翻译成二进制的机器语言。并且不同的CPU`指令集不同`，用汇编语言来编写代码需要做`大量的适配`，并且代码长度很长。所以有了py3，java，js，c，go等高级语言

### 高级语言

`CPU`也不认识高级语言，这时候有两种方法解决：

1. 解释执行，输入代码-解析器解析-中间代码-解释器解释-输出结果
2. 编译执行，输入代码-解析器解析-中间代码-编译器编译-机器代码-执行-输出结果

不同高级语言都有自己的虚拟机去做这些事情，`v8`就是js的`引擎`。苹果是`javascriptCore`，`V8`是谷歌的

## V8工作顺序

### 准备工作

`V8`相当于是病毒，是`寄生`于宿主之上的，所以他需要`宿主提供`一系列环境才能去运行！

- `主线程`
- `内存`初始化`堆栈`结构，存放变量
- `全局执行上下文`，全局对象（window，document、webapi如setTimeout）、this对象（默认指向window）、词法环境（let、const等变量的内容）
- `事件循环系统`，包括`事件驱动器`和`事件队列`，如同v8的心脏不断`接受`消息和`决策`如何处理

V8有的是：

- js核心功能
- `垃圾回收`机制

### 编译，执行 

高级语言执行方式有两种：

- 解释执行
- 编译执行

而V8采用了`JIT`技术，解释执行 + 优化编译执行。

- 结构化代码，生成`ast语法树`
- 生成ast`同时`生成`作用域`
- 解析器解析出`中间代码`(字节码)
- 字节码交给`解释器`解释
- 输出结果
- 高频代码会被`监控解释器`记住，走`优化编译器`
- 编译成机器代码
- 执行
- 产出结果
- 代码改动会进行`反优化操作`重走解释器

## V8如何处理闭包

### 惰性解析

`v8`在编译程序时选择了`惰性解析`，遇到函数声明时并不会解析`函数内部代码`，只会解析`顶级代码`，生成AST和字节码

```js
function foo(){
  return 1;
}
var a = 1;

// 产出AST，下面代码结构类似，但并非真实AST

// function:{
  // foo:{
  //   name: 'foo',
  //   code: 'function foo(){
  //     return 1;
  //   }',
  // }
// }
// variableDeclear:{a:1}
```

这个做法可以大大的`缩短编译`时间  

### 惰性解析如何解决闭包

#### 闭包问题

> 闭包即，函数的内部函数持有了`非本作用域`的变量，并且这个函数被以`返回值`的形式传送到了`外部作用域`。

这是就会产生两个问题：

1. 在外部函数执行结束时，被内部函数引用的变量是否应该销毁？
2. 由于使用惰性解析，没办法知道内部函数引用到了外部变量，所以在栈中，内部函数被外环境所持有，但是外部函数已经被销毁，此时v8并不知道内部函数还用了外部函数的变量。那么变量将会被`错误的销毁`

#### 预解析器来排忧解难

`预解析器`主要负责在`惰性解析`时，快速解析函数内部代码是否存在以下两种情况

1. 代码是否有`错误`
2. 是否存在内部函数引用了外部变量，如果引用了外部变量，`预解析器`会将变量`复制到堆中`。

基于第二点，就算外部函数执行完毕被销毁了，但是内部函数引用的变量被存放在了堆中，所以就不会出错了！

## why字节码？

1. `生成速度快`，比编译成机器码要快得多
2. `体积小`，在做缓存时比二进制机器码要有优势的多，在执行上，V8有最快的优化编译器`TurboFan`，平衡了编译执行时间
3. `移植性更高`，在代码编译成机器码过程中，要考虑不同`CPU`和`系统架构`导致的`兼容性`问题。字节码的执行过程和CPU执行过程类似，所以可以`大幅度降低`兼容代码的量

## 如何编译字节码

## 快属性慢属性

## 原型链

## 作用域链

## 类型系统

> 如果其中一个值的类型是字符串时，则另一个值也需要强制转换为字符串，然后做字符串的连接运算。在其他情况时，所有的值都会转换为数字类型值，然后做数字的相加。

## 隐藏类

## 内联缓存

## 总结

### V8做的优化

#### 编译

1. JIT技术，加快js编译+执行
2. 惰性解析 + 预解析器（解决闭包，查找错误）
3. 使用字节码，加快解析速度，增加V8可移植性

#### 执行

1. 热点代码走优化编译器，产出机器码缓存
2. 