---
layout: post
title: æ²¡äº‹å„¿çœ‹çœ‹Vueæºç ï¼ŒæŒºå¥½çš„
subtitle: code of Vue ğŸ¨
author: "malin"
header-style: text
tags:
  - vue
---

## åˆå§‹åŒ–

```js
vm._self = vm;
initLifecycle(vm); // åˆå§‹åŒ–ç”Ÿå‘½å‘¨æœŸå‡½æ•°
initEvents(vm);    // åˆå§‹åŒ–äº‹ä»¶
initRender(vm);    // è°ƒç”¨renderåˆå§‹åŒ–ç»„ä»¶
callHook(vm, 'beforeCreate');  // è°ƒç”¨beforeCreateé’©å­å‡½æ•°
initInjections(vm); // resolve injections before data/props
initState(vm);      // 
initProvide(vm); // resolve provide after data/props
callHook(vm, 'created'); // è°ƒç”¨createdé’©å­å‡½æ•°  ä¹‹åæ‰æŒ‚è½½ data

// send initial data to native
var data = vm.$options.data;
var params = typeof data === 'function'
  ? getData(data, vm)
  : data || {};
if (isPlainObject(params)) {
  updateComponentData(componentId, params);
}

registerComponentHook(componentId, 'lifecycle', 'attach', function () {
  callHook(vm, 'beforeMount');

  var updateComponent = function () {
    vm._update(vm._vnode, false);
  };
  new Watcher(vm, updateComponent, noop, null, true);

  vm._isMounted = true;
  callHook(vm, 'mounted');
});
```

### initProvide / initInjections
```js
export function initProvide (vm: Component) {
  const provide = vm.$options.provide
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)     // ç»‘å®šthis
      : provide
  }
}

export function initInjections (vm: Component) {
  const result = resolveInject(vm.$options.inject, vm)
  if (result) {
    toggleObserving(false)
    Object.keys(result).forEach(key => {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], () => {
          warn(
            `Avoid mutating an injected value directly since the changes will be ` +
            `overwritten whenever the provided component re-renders. ` +
            `injection being mutated: "${key}"`,
            vm
          )
        })
      } else {
        defineReactive(vm, key, result[key])
      }
    })
    toggleObserving(true)
  }
}
```

## æ•°æ®åŠ«æŒ

è¯¦è§£è¯·çœ‹æˆ‘çš„å¦ä¸€ç¯‡åšæ–‡ï¼š[Vue æ•°æ®åŠ«æŒè¯¦è§£](/2019/08/28/observe/)
### å¯¹è±¡

```js
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: Function
) {
  const dep = new Dep()//åˆ›å»ºè®¢é˜…å¯¹è±¡
 
  const property = Object.getOwnPropertyDescriptor(obj, key)//è·å–objå¯¹è±¡çš„keyå±æ€§çš„æè¿°
  //å±æ€§çš„æè¿°ç‰¹æ€§é‡Œé¢å¦‚æœconfigurableä¸ºfalseåˆ™å±æ€§çš„ä»»ä½•ä¿®æ”¹å°†æ— æ•ˆ
  if (property && property.configurable === false) {
    return
  }
 
  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
 
  let childOb = observe(val)//åˆ›å»ºä¸€ä¸ªè§‚å¯Ÿè€…å¯¹è±¡
  Object.defineProperty(obj, key, {
    enumerable: true,//å¯æšä¸¾
    configurable: true,//å¯ä¿®æ”¹
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val//å…ˆè°ƒç”¨é»˜è®¤çš„getæ–¹æ³•å–å€¼
      //è¿™é‡Œå°±åŠ«æŒäº†getæ–¹æ³•ï¼Œä¹Ÿæ˜¯ä½œè€…ä¸€ä¸ªå·§å¦™è®¾è®¡ï¼Œåœ¨åˆ›å»ºwatcherå®ä¾‹çš„æ—¶å€™ï¼Œé€šè¿‡è°ƒç”¨å¯¹è±¡çš„getæ–¹æ³•å¾€è®¢é˜…å™¨depä¸Šæ·»åŠ è¿™ä¸ªåˆ›å»ºçš„watcherå®ä¾‹
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
        }
        if (Array.isArray(value)) {
          dependArray(value)
        }
      }
      return value//è¿”å›å±æ€§å€¼
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val//å…ˆå–æ—§å€¼
      if (newVal === value) {
        return
      }
      //è¿™ä¸ªæ˜¯ç”¨æ¥åˆ¤æ–­ç”Ÿäº§ç¯å¢ƒçš„ï¼Œå¯ä»¥æ— è§†
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = observe(newVal)//ç»§ç»­ç›‘å¬æ–°çš„å±æ€§å€¼
      dep.notify()//è¿™ä¸ªæ˜¯çœŸæ­£åŠ«æŒçš„ç›®çš„ï¼Œè¦å¯¹è®¢é˜…è€…å‘é€šçŸ¥äº†
    }
  })
}
```

### æ•°ç»„

```js
const arrayProto = Array.prototype//åŸç”ŸArrayçš„åŸå‹
export const arrayMethods = Object.create(arrayProto)
 
;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  const original = arrayProto[method]//ç¼“å­˜å…ƒç´ æ•°ç»„åŸå‹
  //è¿™é‡Œé‡å†™äº†æ•°ç»„çš„å‡ ä¸ªåŸå‹æ–¹æ³•
  def(arrayMethods, method, function mutator () {
    //è¿™é‡Œå¤‡ä»½ä¸€ä»½å‚æ•°åº”è¯¥æ˜¯ä»æ€§èƒ½æ–¹é¢çš„è€ƒè™‘
    let i = arguments.length
    const args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    const result = original.apply(this, args)//åŸå§‹æ–¹æ³•æ±‚å€¼
    const ob = this.__ob__//è¿™é‡Œthis.__ob__æŒ‡å‘çš„æ˜¯æ•°æ®çš„Observer
    let inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
 
...
//å®šä¹‰å±æ€§
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
```
